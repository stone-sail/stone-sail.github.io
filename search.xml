<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>malloc实现概述</title>
    <url>/2022/06/12/malloc-tutorial/</url>
    <content><![CDATA[<h2 id="1-malloc-简介"><a href="#1-malloc-简介" class="headerlink" title="1. malloc 简介"></a>1. malloc 简介</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>malloc() 函数用来动态的分配内存空间:<br>【参数说明】size 为需要分配的内存空间的大小，以字节（Byte）计<br>【返回值】分配成功返回指向该内存的地址，失败则返回 NULL<br>【函数说明】malloc在<code>堆</code>区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的</p>
<img src="/images/malloc-tutorial/IMG_20220612-165355450.png" width="500" height="450">


<p>实现malloc的功能可以有很多方法，本文使用<strong>sbrk</strong>来管理堆上内存分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span></span></span><br></pre></td></tr></table></figure>

<p>Tips：<br>sbrk(0) 通常用于返回堆定的指针<br>sbrk(size) 用于堆上申请size大小的空间，同时返回指向新生成的内存的地址</p>
<h2 id="2-使用sbrk简单实现malloc-v1-0"><a href="#2-使用sbrk简单实现malloc-v1-0" class="headerlink" title="2. 使用sbrk简单实现malloc v1.0"></a>2. 使用sbrk简单实现malloc v1.0</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *p = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">void</span> *request = <span class="built_in">sbrk</span>(size); </span><br><span class="line">  <span class="keyword">if</span> (request == (<span class="type">void</span>*) <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// sbrk failed.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(p == request); <span class="comment">// Not thread safe.</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attention: head in increasing downgrade, so the returns of a pointer to thre previous top of the heap is ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上代码段使用sbrk简单实现了malloc的v1.0版本：在堆区申请size大小的空间并返回对应的指针，当申请不成功时返回nullptr。</p>
<p>malloc v1.0版本实现了基本的功能，接下来需要考虑内存的释放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure>
<p>【参数说明】ptr指针 指向一个要释放内存的内存<br>【函数说明】释放通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。</p>
<p>malloc v1.0仍然存在一下两个问题：</p>
<ol>
<li>如果把malloc v1.0申请的指针传递给free函数，我们无法从原始指针中获取分配的内存大小信息，因此无法正确的释放内存；</li>
<li>由于内存是连续的，我们无法释放一块中间的区域给系统，因此需要将已释放而未返回给操作系统的内存重新利用起来；</li>
</ol>
<h2 id="3-malloc-v2-0"><a href="#3-malloc-v2-0" class="headerlink" title="3. malloc v2.0"></a>3. malloc v2.0</h2><h3 id="3-1-内存数据结构"><a href="#3-1-内存数据结构" class="headerlink" title="3.1 内存数据结构"></a>3.1 内存数据结构</h3><ol>
<li>解决第一个问题的常见技巧是将相关数据写入meta data并存储在我们返回的指针下方的某个空间中，如下图所示：</li>
</ol>
<img src="/images/malloc-tutorial/IMG_20220612-180309917.png" width="500" height="300">

<blockquote>
<p>假设现在堆顶指向0x1000，需要申请0x400个字节。malloc v1.0调用sbrk申请0x400个字节并且会返回指向0x1000的指针。如果我们存储大小为0x10个自己的<code>meta data</code>，则需要返回0x1010给调用方，0x1000~0x1010则存储meta data。</p>
</blockquote>
<ol start="2">
<li>为了能重复利用已经释放的内存，我们可以标记该块已被释放而不将其返回给操作系统，以便将来对malloc的调用可以重新使用该块</li>
</ol>
<p>基于以上两点因此需要能够访问每个块的元信息，并为了为简单起见，使用单链表</p>
<p>所以，对于每个块，我们都希望有类似的东西</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">block_meta</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">block_meta</span> *next;</span><br><span class="line">  <span class="type">int</span> free;</span><br><span class="line">  <span class="type">int</span> magic; <span class="comment">// For debugging only. <span class="doctag">TODO:</span> remove this in non-debug mode. It help up to see which code modified the struct last</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> META_SIZE sizeof(struct block_meta)</span></span><br></pre></td></tr></table></figure>

<p>从block_meta中，可以获取块的大小，是否空闲，以及下一个块是什么。这里有一个用于调试目的的幻数，但这并不是必需的。</p>
<p>此外还需要链接列表的头部：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *global_base = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><p>可以写出malloc v2.0实现流程如下：</p>
<ol>
<li>优先使用空闲的内存块</li>
<li>如果无法找到合适的空闲空间，再使用sbrk从操作系统请求空间并将我们的新块添加到链表的末尾</li>
</ol>
<p>查找合适的空闲空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">block_meta</span> *<span class="built_in">find_free_block</span>(<span class="keyword">struct</span> block_meta **last, <span class="type">size_t</span> size) &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">block_meta</span> *current = global_base;</span><br><span class="line">  <span class="comment">// find the first free and larger size</span></span><br><span class="line">  <span class="keyword">while</span> (current &amp;&amp; !(current-&gt;free &amp;&amp; current-&gt;size &gt;= size)) &#123;</span><br><span class="line">    *last = current;</span><br><span class="line">    current = current-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用sbrk从操作系统中申请空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">block_meta</span> *<span class="built_in">request_space</span>(<span class="keyword">struct</span> block_meta* last, <span class="type">size_t</span> size) &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">block_meta</span> *block;</span><br><span class="line">  block = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">void</span> *request = <span class="built_in">sbrk</span>(size + META_SIZE);</span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">void</span>*)block == request); <span class="comment">// Not thread safe.</span></span><br><span class="line">  <span class="keyword">if</span> (request == (<span class="type">void</span>*) <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// sbrk failed.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (last) &#123; <span class="comment">// NULL on first request.</span></span><br><span class="line">    last-&gt;next = block;</span><br><span class="line">  &#125;</span><br><span class="line">  block-&gt;size = size;</span><br><span class="line">  block-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  block-&gt;free = <span class="number">0</span>;</span><br><span class="line">  block-&gt;magic = <span class="number">0x12345678</span>;</span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取block_meta位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">block_meta</span> *<span class="built_in">get_block_ptr</span>(<span class="type">void</span> *ptr) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">struct</span> block_meta*)ptr - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc v2.0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">block_meta</span> *block;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> align size?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!global_base) &#123; <span class="comment">// First call.</span></span><br><span class="line">    block = <span class="built_in">request_space</span>(<span class="literal">NULL</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    global_base = block;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> block_meta *last = global_base;</span><br><span class="line">    block = <span class="built_in">find_free_block</span>(&amp;last, size);</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123; <span class="comment">// Failed to find free block.</span></span><br><span class="line">      block = <span class="built_in">request_space</span>(last, size);</span><br><span class="line">      <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;      <span class="comment">// Found free block</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> consider splitting block here.</span></span><br><span class="line">      block-&gt;free = <span class="number">0</span>;</span><br><span class="line">      block-&gt;magic = <span class="number">0x77777777</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(block+<span class="number">1</span>);  <span class="comment">// return a pointer to the region after block_meta</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>free实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> consider merging blocks once splitting blocks is implemented.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">block_meta</span>* block_ptr = <span class="built_in">get_block_ptr</span>(ptr);</span><br><span class="line">  <span class="built_in">assert</span>(block_ptr-&gt;free == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(block_ptr-&gt;magic == <span class="number">0x77777777</span> || block_ptr-&gt;magic == <span class="number">0x12345678</span>);</span><br><span class="line">  block_ptr-&gt;free = <span class="number">1</span>;</span><br><span class="line">  block_ptr-&gt;magic = <span class="number">0x55555555</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用malloc v2.0提供的malloc和free函数，我们已经可以使用自定义内存分配器编写程序了。但在实际的应用场景中，我们还需要实现几个更常见的函数，realloc和calloc。</p>
<h2 id="4-Realloc-和-Calloc的实现"><a href="#4-Realloc-和-Calloc的实现" class="headerlink" title="4. Realloc 和 Calloc的实现"></a>4. Realloc 和 Calloc的实现</h2><h3 id="4-1-Realloc"><a href="#4-1-Realloc" class="headerlink" title="4.1 Realloc"></a>4.1 Realloc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>整体流程如下：</p>
<pre class="mermaid">graph TD;
    s[start] --> ptr_judge{ptr is null}
    ptr_judge --> |Y|call_malloc["call malloc"] --> e["end"]
    ptr_judge --> |N|size_judge{size > ptr.size}
    size_judge --> |N|do_nothing["do nothing"]  --> e
    size_judge --> |Y|malloc_size["call malloc(size)"]
    malloc_size --> memcpy(ptr, new_ptr)
    memcpy --> free["free ptr"] --> e</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">    <span class="comment">// NULL ptr. realloc should act like malloc.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">block_meta</span>* block_ptr = <span class="built_in">get_block_ptr</span>(ptr);</span><br><span class="line">  <span class="keyword">if</span> (block_ptr-&gt;size &gt;= size) &#123;</span><br><span class="line">    <span class="comment">// We have enough space. Could free some once we implement split.</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Need to really realloc. Malloc new space and free old space.</span></span><br><span class="line">  <span class="comment">// Then copy old data to new space.</span></span><br><span class="line">  <span class="type">void</span> *new_ptr;</span><br><span class="line">  new_ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// <span class="doctag">TODO:</span> set errno on failure.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(new_ptr, ptr, block_ptr-&gt;size);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="keyword">return</span> new_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Calloc"><a href="#4-2-Calloc" class="headerlink" title="4.2 Calloc"></a>4.2 Calloc</h3><p>对Calloc我们仅仅需要再返回指针前对内存进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nelem, <span class="type">size_t</span> elsize)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> size = nelem * elsize; <span class="comment">// <span class="doctag">TODO:</span> check for overflow.</span></span><br><span class="line">  <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">memset</span>(ptr, <span class="number">0</span>, size);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>memory</category>
      </categories>
      <tags>
        <tag>memory</tag>
        <tag>malloc</tag>
        <tag>system</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/06/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>hide</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>c++有用的工具网站</title>
    <url>/2022/06/25/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>分享几个好用的C++在线工具，能帮助我们深入理解C++极其内部原理</p>
<h2 id="1-Compiler-Explorer"><a href="#1-Compiler-Explorer" class="headerlink" title="1.Compiler Explorer"></a>1.<a href="https://godbolt.org/">Compiler Explorer</a></h2><p><strong>简介：</strong> 这是一个在线汇编代码分析网站，它将C++代码编译成汇编语言，然后用一种用户十分友好的方式显示出来，将C++代码和汇编代码用相同颜色对应起来，当我们把鼠标放到汇编指令时会有对应的指令介绍。它支持用不同版本的编译器和优化级别。它还支持用三方库，包括boost、eigen等。目前已经支持C, C++, C#, F#, Rust, Go, D, Haskell, Swift, Pascal, ispc, Python, Java等超过30多种语言<br><strong>url：</strong> <a href="https://godbolt.org/">godbolt</a><br><strong>github：</strong><a href="https://github.com/compiler-explorer/compiler-explorer">Compiler Explorer github</a></p>
<p><img src="/../images/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/IMG_20220625-205729301.png" alt="picture 2">  </p>
<h2 id="2-wandbox"><a href="#2-wandbox" class="headerlink" title="2.wandbox"></a>2.<a href="https://wandbox.org/">wandbox</a></h2><p><strong>简介：</strong> 一个支持多语言的在线编译的网站，我们可以快速地在里面写实验代码。它支持的语言包括C++、C、rust、python、java等等。它支持多个编译器版本，我们可以用它来测试C++20的新功能<br><strong>url：</strong> <a href="https://wandbox.org/">wandbox</a><br><strong>github：</strong><a href="https://github.com/melpon/wandbox">wandbox github</a></p>
<p><img src="/../images/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/IMG_20220625-210905070.png" alt="picture 3">  </p>
<h2 id="3-Quick-C-Benchmark"><a href="#3-Quick-C-Benchmark" class="headerlink" title="3.Quick C++ Benchmark"></a>3.<a href="https://quick-bench.com/">Quick C++ Benchmark</a></h2><p><strong>简介：</strong> C++代码benchmark的在线工具，我们可以通过它来快速benchmark小的代码片段<br><strong>url：</strong> <a href="https://quick-bench.com/">Quick C++ Benchmark</a><br><strong>github：</strong><a href="https://github.com/FredTingaud">Quick C++ Benchmark github</a></p>
<p><img src="/../images/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/IMG_20220625-211122151.png" alt="picture 4">  </p>
<h2 id="4-Compare-C-Build"><a href="#4-Compare-C-Build" class="headerlink" title="4.Compare C++ Build"></a>4.<a href="https://build-bench.com/">Compare C++ Build</a></h2><p><strong>简介：</strong> 对代码编译进行时间、CPU、内存等开销的测量。它和Quick C++ Benchmark是同一个人写的。<br><strong>url：</strong> <a href="https://build-bench.com/">Compare C++ Build</a><br><strong>github：</strong><a href="https://github.com/FredTingaud">Compare C++ Build github</a></p>
<p><img src="/../images/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/IMG_20220625-212900570.png" alt="picture 7">  </p>
<h2 id="5-C-Insight"><a href="#5-C-Insight" class="headerlink" title="5.C++ Insight"></a>5.<a href="https://cppinsights.io/">C++ Insight</a></h2><p><strong>简介：</strong> 一个允许我们查看C++编译器如何将C++代码转换的中间文件，尤其是模版的展开的情况，非常insightful。<br><strong>url：</strong> <a href="https://cppinsights.io/">C++ Insight</a><br><strong>github：</strong><a href="https://github.com/andreasfertig/cppinsights">C++ Insight github</a><br><img src="/../images/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/IMG_20220625-211654271.png" alt="picture 5">  </p>
<h2 id="6-C-Jupyter-Notebook"><a href="#6-C-Jupyter-Notebook" class="headerlink" title="6.C++ Jupyter Notebook"></a>6.<a href="https://mybinder.org/v2/gh/jupyter-xeus/xeus-cling/stable?filepath=notebooks/xcpp.ipynb">C++ Jupyter Notebook</a></h2><p><strong>简介：</strong> 这个工具是Jupyter和C++解释器Cling的一个结合体，它允许我们快速测试代码和可视化数据。<br><strong>url：</strong> <a href="https://mybinder.org/v2/gh/jupyter-xeus/xeus-cling/stable?filepath=notebooks/xcpp.ipynb">C++ Jupyter Notebook</a><br><strong>github：</strong><a href="https://github.com/jupyter-xeus/xeus-cling">C++ Jupyter Notebook github</a><br><img src="/../images/c++%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/IMG_20220625-212505837.png" alt="picture 6">  </p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>105 从前序与中序遍历序列构造二叉树</title>
    <url>/2022/07/26/leetcode/leetcode_105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p><img src="/../../images/leetcode_105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/IMG_20220706-130539414.png" alt="picture 1">  </p>
<blockquote>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>套用二叉树的框架，这个题本质上是一个前序遍历问题。<br>需要注意的是：buildTree 中 <strong>preorder 和 inorder 起点到终点的个数要保持一致</strong>，否则不容易ac.</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> VecInt = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buildTree</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>(), inorder, <span class="number">0</span>,</span><br><span class="line">                     inorder.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(VecInt&amp; preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                      VecInt&amp; inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt;= preEnd || inStart &gt;= inEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = inStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; inEnd; ++idx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (inorder[idx] == preorder[preStart]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= inEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> leftNum = idx - inStart;</span><br><span class="line"></span><br><span class="line">    TreeNode* result = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preStart]);</span><br><span class="line">    result-&gt;left = <span class="built_in">buildTree</span>(preorder, preStart + <span class="number">1</span>, preStart + <span class="number">1</span> + leftNum,</span><br><span class="line">                             inorder, inStart, idx);</span><br><span class="line">    result-&gt;right = <span class="built_in">buildTree</span>(preorder, preStart + <span class="number">1</span> + leftNum, preEnd, inorder,</span><br><span class="line">                              idx + <span class="number">1</span>, inEnd);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode framework</title>
    <url>/2022/06/27/leetcode/leetcode-framework/</url>
    <content><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h2><p>刷题一般现从二叉树开始刷，因为二叉树容易培养框架思维，而且大部分的算法技巧本质上都是二叉树的遍历问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前序遍历代码位置</span></span><br><span class="line">  <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">  <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">  <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">  <span class="comment">// 后续遍历代码位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上几行代码，几乎所有的二叉树题目都是一套这个框架就出来了。</p>
<span id="more"></span>

<h3 id="1-1-前序遍历"><a href="#1-1-前序遍历" class="headerlink" title="1.1 前序遍历"></a>1.1 前序遍历</h3><ul>
<li><a href="/2022/07/26/leetcode/leetcode_105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" title="105 从前序与中序遍历序列构造二叉树">105 从前序与中序遍历序列构造二叉树</a></li>
</ul>
<h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><ul>
<li><a href="/2022/07/26/leetcode/leetcode_99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="99. 恢复二叉搜索树">99. 恢复二叉搜索树</a></li>
</ul>
<h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><ul>
<li><a href="/2022/07/06/leetcode/leetcode_124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="124. 二叉树中的最大路径和">124. 二叉树中的最大路径和</a></li>
</ul>
<h2 id="2-linked-list"><a href="#2-linked-list" class="headerlink" title="2. linked list"></a>2. linked list</h2><p>链表的六个技巧</p>
<ul>
<li><a href="/2022/07/11/leetcode/leetcode_21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/" title="21. 合并两个有序链表">21. 合并两个有序链表</a>
</li>
<li><a href="/2022/07/03/leetcode/leetcode_23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/" title="23. 合并K个升序链表">23. 合并K个升序链表</a>
</li>
<li><a href="/2022/07/11/leetcode/leetcode_141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/" title="141. 环形链表">141. 环形链表</a>
</li>
<li><a href="/2022/07/11/leetcode/leetcode_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/" title="142. 环形链表2">142. 环形链表2</a>
</li>
<li><a href="/2022/07/11/leetcode/leetcode_160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" title="160. 相交链表">160. 相交链表</a>
</li>
<li><a href="/2022/06/27/leetcode/leetcode_19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/" title="19. 删除链表的倒数第N个节点">19. 删除链表的倒数第N个节点</a></li>
</ul>
<hr>
<ul>
<li><a href="/2022/07/04/leetcode/leetcode_25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" title="25. K 个一组翻转链表">25. K 个一组翻转链表</a></li>
</ul>
<h2 id="3-前缀和"><a href="#3-前缀和" class="headerlink" title="3. 前缀和"></a>3. 前缀和</h2><p>前缀和的定义：<br>我们求数列的和时，Sn &#x3D; a1+a2+a3+…an; 此时Sn就是数列的前 n 项和。例 S5 &#x3D; a1 + a2 + a3 + a4 + a5; S2 &#x3D; a1 + a2。所以我们完全可以通过 S5-S2 得到 a3+a4+a5 的值，这个过程就和我们做题用到的前缀和思想类似。我们的前缀和数组里保存的就是前 n 项的和。</p>
<p>前缀和是以求和的方式灵活地面对区间询问,如以下：</p>
<ul>
<li><a href="/2022/07/12/leetcode/leetcode_303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/" title="303. 区域和检索">303. 区域和检索</a>
</li>
<li><a href="/2022/07/11/leetcode/leetcode_304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/" title="304. 二维区域和检索">304. 二维区域和检索</a>
</li>
<li><a href="/2022/07/26/leetcode/leetcode_560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" title="560. 和为k的子数组">560. 和为k的子数组</a></li>
</ul>
<h2 id="4-差分数组"><a href="#4-差分数组" class="headerlink" title="4. 差分数组"></a>4. 差分数组</h2><p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</p>
<p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行加减，核心代码如下:</p>
<p>我们先对 nums 数组构造一个 diff 差 分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差： </p>
<p><img src="/../../images/leetcode-framework/IMG_20220723-182345788.png" alt="picture 1">  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="type">int</span>[nums.length]; <span class="comment">// 构造差分数组 diff[0] = nums[0];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="type">int</span>[diff.length]; <span class="comment">// 根据差分数组构造结果数组 res[0] = diff[0];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">  res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>** 这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] +&#x3D; 3，然后再让 diff[j+1] -&#x3D; 3 即可 **</p>
<blockquote>
<p>原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] +&#x3D; 3 意味着给 nums[i..] 所有的元素都 加了 3，然后 diff[j+1] -&#x3D; 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了？</p>
</blockquote>
<p>差分数组工具类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Difference</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    diff_.<span class="built_in">emplace_back</span>(num[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      diff_.<span class="built_in">emplace</span>(diff[i] - diff[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; diff_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      diff_[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j+<span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; j+<span class="number">1</span> &lt; diff_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      diff_[j+<span class="number">1</span>] -= val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;in&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (diff_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;in&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(diff_.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    result[<span class="number">0</span>] = diff_[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      result[i] = result[i<span class="number">-1</span>] + diff_[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; diff_; <span class="comment">// 差分数组  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="/2022/07/24/leetcode/leetcode_1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/" title="1109. 航班预订统计">1109. 航班预订统计</a></li>
</ul>
<h2 id="5-滑动窗口"><a href="#5-滑动窗口" class="headerlink" title="5. 滑动窗口"></a>5. 滑动窗口</h2><p>滑动窗口的大致算法逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="comment">// 增大窗口</span></span><br><span class="line">  windows.<span class="built_in">add</span>(s[right]);</span><br><span class="line">  ++right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">    <span class="comment">// 缩小窗口</span></span><br><span class="line">    windows.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口算法框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口采用双指针实现</span></span><br><span class="line"><span class="comment">// s: 检查的长字符串</span></span><br><span class="line"><span class="comment">// t: 需要的短字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindows</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">  unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> c : t) &#123; need[c] += <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> c = s[right];</span><br><span class="line">    ++right;</span><br><span class="line">    <span class="comment">// 进行窗口内数据的一系列更新 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩 </span></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">      <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">      <span class="type">char</span> d = s[left]; </span><br><span class="line">      <span class="comment">// 左移窗口</span></span><br><span class="line">      left++; </span><br><span class="line">      <span class="comment">// 进行窗口内数据的一系列更新 </span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中两处 … 表示的更新窗口数据的地方，到时候你直接往里面填就行了。 而且，这两个 … 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。</p>
<ul>
<li><a href="/2022/07/26/leetcode/leetcode_76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" title="76. 最小覆盖子串">76. 最小覆盖子串</a></li>
</ul>
<p>字符串排列<br>给定两个字符串s1和s2，写一个函数来判断s2是否包含s1的排列<br>换句话说，第一个字符串的排列之一是第二个字符串的子串</p>
<ul>
<li><a href="/2022/11/26/leetcode/leetcode_567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/" title="567. 字符串的排列">567. 字符串的排列</a></li>
<li><a href="/2022/11/26/leetcode/leetcode_438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/" title="438. 找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</a></li>
</ul>
<h2 id="6-二分查找"><a href="#6-二分查找" class="headerlink" title="6. 二分查找"></a>6. 二分查找</h2><ol>
<li>查找某个数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binarySearch(const std::vector&lt;int&gt;&amp; array, int val) &#123;</span><br><span class="line">  int left = 0, right = array.size();</span><br><span class="line">  while(left &lt; right) &#123;</span><br><span class="line">    int mid = left  + (right - left) / 2;</span><br><span class="line">    if (num[mid] == target) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = ...;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = ...;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>寻找左侧边界的二分搜索</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int left_bound(const std::vector&lt;int&gt;&amp; array, int val) &#123;</span><br><span class="line">  if (array.empty()) return -1;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = array.size();  // 注意</span><br><span class="line"></span><br><span class="line">  while (left &lt; right) &#123;  // 注意</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    </span><br><span class="line">    if (array[mid] == val) &#123;</span><br><span class="line">      right = mid;</span><br><span class="line">    &#125; else if (array[mid] &lt; val) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (array[mid] &gt; val) &#123;</span><br><span class="line">      right = mid;  // 注意</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>寻找右侧边界的二分搜索</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int right_bound(const std::vector&lt;int&gt;&amp; array, int val) &#123;</span><br><span class="line">  if (array.empty()) return -1;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = array.size();  // 注意</span><br><span class="line"></span><br><span class="line">  while (left &lt; right) &#123; // 注意</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    </span><br><span class="line">    if (array[mid] == val) &#123;</span><br><span class="line">      left = mid + 1;   // 注意</span><br><span class="line">    &#125; else if (array[mid] &lt; val) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (array[mid] &gt; val) &#123;</span><br><span class="line">      right = mid;   // 注意  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return left - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全部统一成两端都闭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binary_search(const std::vector&lt;int&gt;&amp; array, int target) &#123;</span><br><span class="line">  if (array.empty()) return -1;</span><br><span class="line"></span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = array.size() - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    </span><br><span class="line">    if (array[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (array[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int left_bound(const std::vector&lt;int&gt;&amp; array, int target) &#123;</span><br><span class="line">  if (array.empty()) return -1;</span><br><span class="line"></span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = array.size() - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    if (array[mid] == target) &#123;</span><br><span class="line">      right = mid - 1;  // attention</span><br><span class="line">    &#125; else if (array[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (array[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // attention</span><br><span class="line">  // 最后要检查 left 越界的情况</span><br><span class="line">  if (left &gt;= nums.length || nums[left] != target) return -1;</span><br><span class="line"></span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int right_bound(const std::vector&lt;int&gt;&amp; array, int target) &#123;</span><br><span class="line">  if (array.empty()) return -1;</span><br><span class="line"></span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = array.size() - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    if (array[mid] == target) &#123;</span><br><span class="line">      left = mid +1 1;   // attention</span><br><span class="line">    &#125; else if (array[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (array[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // attention</span><br><span class="line">  // 最后要检查 left 越界的情况</span><br><span class="line">  if (right &lt; 0 || nums[right] != target) return -1;</span><br><span class="line"></span><br><span class="line">  return right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h2><p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。<br>单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。</p>
<h3 id="7-1-单调栈模板"><a href="#7-1-单调栈模板" class="headerlink" title="7.1 单调栈模板"></a>7.1 单调栈模板</h3><p>给你一个数组 nums，请你返回一个等⻓的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有 更大的元素，就存 -1。 函数签名如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums); </span><br><span class="line"></span><br><span class="line">比如说，输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。 解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。 </span><br></pre></td></tr></table></figure>

<p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你 站成一列，如何求元素「2」的 Next Greater Number 呢？ </p>
<p>很简单，如果能够看到元素「2」，那么他后面可⻅的第一个人就是「2」的 Next Greater Number，因为比 「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">  vector&lt;int&gt; res(nums.size()); // 存放答案的数组 </span><br><span class="line">  stack&lt;int&gt; s; </span><br><span class="line">  // 倒着往栈里放 </span><br><span class="line">  for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    // 判定个子高矮 </span><br><span class="line">    while (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123;</span><br><span class="line">      // 矮个起开，反正也被挡着了。。。</span><br><span class="line">      s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    // nums[i] 身后的 next great number </span><br><span class="line">    res[i] = s.empty() ? -1 : s.top(); </span><br><span class="line">    s.push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="/2023/01/26/leetcode/leetcode_239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/" title="239. 滑动窗口最大值">239. 滑动窗口最大值</a></li>
<li><a href="/2023/01/26/leetcode/leetcode_503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/" title="503. 下一个更大元素II">503. 下一个更大元素II</a></li>
</ul>
<h3 id="7-2-去除重复字母"><a href="#7-2-去除重复字母" class="headerlink" title="7.2 去除重复字母"></a>7.2 去除重复字母</h3><p>参考： <a href="https://mp.weixin.qq.com/s/Yq49ZBEW3DJx6nXk1fMusw">https://mp.weixin.qq.com/s/Yq49ZBEW3DJx6nXk1fMusw</a></p>
<ul>
<li><a href="/2023/01/26/leetcode/leetcode_316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/" title="316. 去除重复字母">316. 去除重复字母</a></li>
</ul>
<hr>
<p>以下是数据结构</p>
<h2 id="8-LRU算法"><a href="#8-LRU算法" class="headerlink" title="8. LRU算法"></a>8. LRU算法</h2><ul>
<li><a href="/2023/01/26/leetcode/leetcode_146-LRU%E7%BC%93%E5%AD%98/" title="146. LRU缓存">146. LRU缓存</a></li>
</ul>
<p>可以参考lfu算法</p>
<h2 id="9-优先级队列"><a href="#9-优先级队列" class="headerlink" title="9. 优先级队列"></a>9. 优先级队列</h2><ul>
<li><a href="/2023/01/26/leetcode/leetcode_295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" title="295. 数据流的中位数">295. 数据流的中位数</a>
参考： <a href="https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg">https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg</a></li>
</ul>
<h2 id="10-二叉树"><a href="#10-二叉树" class="headerlink" title="10. 二叉树"></a>10. 二叉树</h2><p>我们公众号的成名之作 学习数据结构和算法的框架思维 中多次强调，先刷二叉树的题目，先刷二叉树的题 目，先刷二叉树的题目，因为很多经典算法，以及我们前文讲过的所有回溯、动归、分治算法，其实都是树 的问题，而树的问题就永远逃不开树的递归遍历框架这几行破代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 二叉树遍历框架 */ </span><br><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">  // 前序遍历 </span><br><span class="line">  traverse(root.left) </span><br><span class="line">  // 中序遍历 </span><br><span class="line">  traverse(root.right) </span><br><span class="line">  // 后序遍历 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-1-二叉树的重要性"><a href="#10-1-二叉树的重要性" class="headerlink" title="10.1 二叉树的重要性"></a>10.1 二叉树的重要性</h3><p>举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？如果你 告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法 高手了。 为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：</p>
<p>快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。 快速排序的代码框架如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sort(int[] nums, int lo, int hi) &#123; </span><br><span class="line">  /****** 前序遍历位置 ******/ </span><br><span class="line">  // 通过交换元素构建分界点 p </span><br><span class="line">  int p = partition(nums, lo, hi); </span><br><span class="line">  /************************/ </span><br><span class="line">  sort(nums, lo, p - 1); </span><br><span class="line">  sort(nums, p + 1, hi); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？ </p>
<p>再说说归并排序的逻辑，若要对 nums[lo..hi] 进行排序，我们先对 nums[lo..mid] 排序，再对 nums[mid+1..hi] 排序，最后把这两个有序的子数组合并，整个数组就排好序了。 </p>
<p>归并排序的代码框架如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sort(int[] nums, int lo, int hi) &#123; </span><br><span class="line">  int mid = (lo + hi) / 2; </span><br><span class="line">  sort(nums, lo, mid); </span><br><span class="line">  sort(nums, mid + 1, hi); </span><br><span class="line">  /****** 后序遍历位置 ******/ </span><br><span class="line">  // 合并两个排好序的子数组 </span><br><span class="line">  merge(nums, lo, mid, hi); </span><br><span class="line">  /************************/ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另 外，这不就是传说中的分治算法嘛，不过如此呀。 </p>
<p>如果你一眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是手到擒来，从框架慢慢扩展就能 写出算法了。 </p>
<p>说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树 的问题</p>
<h3 id="10-2-写递归算法的秘诀"><a href="#10-2-写递归算法的秘诀" class="headerlink" title="10.2 写递归算法的秘诀"></a>10.2 写递归算法的秘诀</h3><p>我们前文 二叉树的最近公共祖先 写过，写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定 义，利用这个定义推导最终结果，绝不要跳入递归的细节。</p>
<p>怎么理解呢，我们用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义：count(root) 返回以 root 为根的树有多少节点 </span><br><span class="line">int count(TreeNode root) &#123; </span><br><span class="line">  // base case </span><br><span class="line">  if (root == null) return 0;</span><br><span class="line">  // 自己加上子树的节点数就是整棵树的节点数 </span><br><span class="line">  return 1 + count(root.left) + count(root.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题非常简单，大家应该都会写这段代码，root 本身就是一个节点，加上左右子树的节点数就是以 root 为根的树的节点总数。 左右子树的节点数怎么算？</p>
<p>其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义， 递归调用 count 函数即可算出来。 </p>
<p>写树相关的算法，简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数 定义递归调用子节点，递归调用会让孩子节点做相同的事情。 </p>
<p>所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思 考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。</p>
<p>二叉搜索树（简写作 BST）的性质: 简单说就是「左小右大」，对于每个节点，整棵左子 树都比该节点的值小， 整棵右子树都比该节点的值大。 另外： 按照 BST 的定义，任何一个单独的节点肯定是 BST</p>
<p>BST 是一种特殊的二叉树，你只要记住它的两个主要特点：<br>1、左小右大，即每个节点的左子树都比当前节点的值小，右子树都比当前节点的值大。<br>2、中序遍历结果是有序的。 </p>
<ul>
<li><a href="/2023/01/26/leetcode/leetcode_236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" title="236. 二叉树的最近公共祖先">236. 二叉树的最近公共祖先</a></li>
<li><a href="/2023/01/26/leetcode/leetcode_ds_%E4%BA%8C%E5%8F%89%E6%A0%91/" title="ds. 二叉树">ds. 二叉树</a></li>
</ul>
<p>参考：<br><a href="https://mp.weixin.qq.com/s/izZ5uiWzTagagJec6Y7RvQ">东哥手把手带你刷二叉树（第一期）</a ></p>
<p><a href="https://mp.weixin.qq.com/s/OlpaDhPDTJlQ5MJ8tsARlA">东哥手把手带你刷二叉树（第二期）</a ></p>
<p><a href="https://mp.weixin.qq.com/s/LJbpo49qppIeRs-FbgjsSQ">东哥手把手带你刷二叉树（第三期）</a ></p>
<h2 id="11-其他"><a href="#11-其他" class="headerlink" title="11. 其他"></a>11. 其他</h2><ul>
<li><a href="/2022/06/27/leetcode/leetcode_2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/" title="2. 两数相加">2. 两数相加</a></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>124. 二叉树中的最大路径和</title>
    <url>/2022/07/06/leetcode/leetcode_124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><img src="/../../images/leetcode_124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/IMG_20220706-163343590.png" alt="picture 2">  </p>
<blockquote>
<p>输入：root &#x3D; [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>采用后序遍历的框架，tips:</p>
<blockquote>
<p>int leftpath &#x3D; max(0, SideMaxPath(root-&gt;left)); </p>
</blockquote>
<p>这样写可以使得后面的逻辑比较简单，不需要额外的判断条件</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">SideMaxPath</span>(root);</span><br><span class="line">      <span class="keyword">return</span> max_depth_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SideMaxPath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> leftpath = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">SideMaxPath</span>(root-&gt;left));</span><br><span class="line">      <span class="type">int</span> rightpath = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">SideMaxPath</span>(root-&gt;right));</span><br><span class="line">      max_depth_ = <span class="built_in">max</span>(max_depth_, root-&gt;val + leftpath + rightpath);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">max</span>(leftpath + root-&gt;val, rightpath + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">int</span> max_depth_ = INT_MIN;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>1109. 航班预订统计</title>
    <url>/2022/07/24/leetcode/leetcode_1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] &#x3D; [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p>
<blockquote>
<p>输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5<br>输出：[10,55,45,25,25]<br>解释：<br>航班编号        1   2   3   4   5<br>预订记录 1 ：   10  10<br>预订记录 2 ：       20  20<br>预订记录 3 ：       25  25  25  25<br>总座位数：      10  55  45  25  25<br>因此，answer &#x3D; [10,55,45,25,25]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>使用差分数组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">diff</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : bookings) &#123;</span><br><span class="line">        diff[val[<span class="number">0</span>]<span class="number">-1</span>] += val[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (val[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">          diff[val[<span class="number">1</span>]] -= val[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// for (auto val : diff) &#123;</span></span><br><span class="line">      <span class="comment">//   std::cout &lt;&lt; val &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">      <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> val : diff) &#123;</span><br><span class="line">        tmp += val;</span><br><span class="line">        result.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2022/07/11/leetcode/leetcode_141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>主要使用快慢指针的思路，快指针每次移动2次，慢指针每次移动一次，当链表中存在环时，快慢指针会指向同一个节点</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode* first = head;</span><br><span class="line">      ListNode* second = first;</span><br><span class="line">      <span class="keyword">while</span> (first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">nullptr</span> &amp;&amp; (first == second)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第N个节点</title>
    <url>/2022/06/27/leetcode/leetcode_19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<blockquote>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>采用双指针计数的方式找到目标节点的<strong>前一个</strong>节点，设置 <strong>node-&gt;next &#x3D; node-&gt;next-&gt;next</strong> 删除目标节点</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">      ListNode* first, *second;</span><br><span class="line">      first = second = head;</span><br><span class="line">      <span class="keyword">while</span> ((second != <span class="literal">nullptr</span>) &amp;&amp; (n-- &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// n &gt; 队列长度</span></span><br><span class="line">      <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// n == 队列长度 则删除头结点</span></span><br><span class="line">      <span class="keyword">if</span> (second == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// n &lt; 队列长度，获取倒数n+1个节点，删除倒数n个点解</span></span><br><span class="line">      <span class="keyword">while</span> (second-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>142. 环形链表2</title>
    <url>/2022/07/11/leetcode/leetcode_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>主要使用快慢指针的思路，根据- <a href="#">Post not found: leetcode/leetcode_141-循环链表</a> 的思路，求两次交点：</p>
<ol>
<li>快指针每次移动2个节点，慢指针移动一个节点，看是否有交点，没有交点则不是循环链表</li>
<li>快指针指向头节点，快慢指针每次移动一次求交点，结果为链表开始入环的第一个节点</li>
</ol>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      ListNode *first, *second;</span><br><span class="line">      first = second = head;</span><br><span class="line">      <span class="keyword">while</span> (first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (first == second) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (first == <span class="literal">nullptr</span> || first-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      second = head;</span><br><span class="line">      <span class="keyword">while</span> (first != second) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>160. 相交链表</title>
    <url>/2022/07/11/leetcode/leetcode_160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>把A和B两个链表合并起来组成c1 &#x3D; A-&gt;B, c2 &#x3D; B-&gt;A，则c1和c2的长度相同而且相交部分的长度相同，因此遍历C1和C2，首先找到的公共节点就是两个链表相交的起始节点</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (headB == <span class="literal">nullptr</span> || headA == <span class="literal">nullptr</span> )  &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode* pa = headA, *pb = headB;</span><br><span class="line">      <span class="keyword">while</span>(pa != pb) &#123;</span><br><span class="line">        pa = (pa == <span class="literal">nullptr</span>) ? headB : pa-&gt;next;</span><br><span class="line">        pb = (pb == <span class="literal">nullptr</span>) ? headA : pb-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU缓存</title>
    <url>/2023/01/26/leetcode/leetcode_146-LRU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p>示例：</p>
<blockquote>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
</blockquote>
<blockquote>
<p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><span id="more"></span>
<p>考虑减少耗时，可以考虑优化减少map的删除操作，直接修改赋值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">cap_</span>(capacity) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//std::cout &lt;&lt; &quot;get key: &quot; &lt;&lt; key &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="keyword">auto</span> findIter = keyMap_.<span class="built_in">find</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (findIter == keyMap_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> value = findIter-&gt;second-&gt;second;</span><br><span class="line">      <span class="comment">//std::cout &lt;&lt; &quot;get key: &quot; &lt;&lt; key &lt;&lt; &quot; value: &quot; &lt;&lt; value &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="built_in">put</span>(key, value);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> findIter = keyMap_.<span class="built_in">find</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (findIter == keyMap_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val_.<span class="built_in">size</span>() == cap_) &#123;</span><br><span class="line">          <span class="type">int</span> curkey = val_.<span class="built_in">back</span>().first;</span><br><span class="line">          findIter = keyMap_.<span class="built_in">find</span>(curkey);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除原有数据</span></span><br><span class="line">      <span class="keyword">if</span> (findIter != keyMap_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        val_.<span class="built_in">erase</span>(findIter-&gt;second);</span><br><span class="line">        keyMap_.<span class="built_in">erase</span>(findIter);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入新数据</span></span><br><span class="line">      val_.<span class="built_in">push_front</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">      keyMap_[key] = val_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//std::cout &lt;&lt; &quot;put&quot; &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="comment">//for (auto val : val_) &#123;</span></span><br><span class="line">      <span class="comment">//  //std::cout &lt;&lt; val.first &lt;&lt; &quot; , &quot; &lt;&lt; val.second-&gt;second &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="comment">//  std::cout &lt;&lt; val.first &lt;&lt; &quot; , &quot; &lt;&lt; val.second &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cap_ = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; keyMap_;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; val_;  <span class="comment">// for key, value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2022/06/27/leetcode/leetcode_2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<blockquote>
<p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>由于链表是逆序，因此只需要将两个输入链表的数字逐一相加，并加上进位即可</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">      ListNode* t1 = l1;</span><br><span class="line">      ListNode* t2 = l2;</span><br><span class="line">      ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">      ListNode* current = head;</span><br><span class="line">       </span><br><span class="line">      <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(t1 != <span class="literal">nullptr</span> || t2 != <span class="literal">nullptr</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (t1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          sum += t1-&gt;val;</span><br><span class="line">          t1 = t1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          sum += t2-&gt;val;</span><br><span class="line">          t2 = t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2022/07/11/leetcode/leetcode_21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<blockquote>
<p>输入：l1 &#x3D; [], l2 &#x3D; []<br>输出：[]</p>
</blockquote>
<blockquote>
<p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>把两个有序链表通过比较大小依次合并到新链表,注意不要忘记把剩余的部分也合并进去。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">      ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">      ListNode* node = head;</span><br><span class="line">      <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">          cur = list1;</span><br><span class="line">          list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cur = list2;</span><br><span class="line">          list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;next = cur;</span><br><span class="line">        node = cur;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (list1) &#123;</span><br><span class="line">        node-&gt;next = list1;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = list2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 合并K个升序链表</title>
    <url>/2022/07/03/leetcode/leetcode_23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<blockquote>
<p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>ref: <a href="/2022/06/27/leetcode/leetcode_19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/" title="19. 删除链表的倒数第N个节点">19. 删除链表的倒数第N个节点</a><br>可以使用 19.删除链表的倒数第N个结点 每两个链表合并，也可以从k个链表中找到合适的node进行合并</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">      ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">      ListNode* node = head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (count &lt; lists.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_index = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">          <span class="keyword">auto</span>* val = lists[i];</span><br><span class="line">          <span class="keyword">if</span> (val == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (min_index == INT_MIN) &#123;</span><br><span class="line">            min_index = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val-&gt;val &lt; lists[min_index]-&gt;val) &#123;</span><br><span class="line">            min_index = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_index == INT_MIN) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = lists[min_index];</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        lists[min_index] = node-&gt;next;</span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (head == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <url>/2023/01/26/leetcode/leetcode_236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<blockquote>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>&#x2F;&#x2F; 分成两部分 构造大根堆 和 小根堆</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">      auto* result = findAncestor(root, p, q);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* findAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line"></span><br><span class="line">      // 先搞清楚当前 root 节点「该做什么」</span><br><span class="line">      if (root == nullptr) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (root == p || root == q) &#123;</span><br><span class="line">        return root;</span><br><span class="line">      &#125;</span><br><span class="line">      // 先搞清楚当前 root 节点「该做什么」</span><br><span class="line"></span><br><span class="line">      // 「什么时候做」，就是让你思 考这段代码到底应该写在前序、中序还是后序遍历的代码位置上</span><br><span class="line">      // 分三种状态返回： </span><br><span class="line">      // 1. 两个节点分别在左右子树上，则返回公共的父节点</span><br><span class="line">      // 2. 两个节点都在左子树上，则公共节点为左子树节点</span><br><span class="line">      // 3. 两个节点都在右子树，则公共节点为右子树节点</span><br><span class="line">      auto* left = findAncestor(root-&gt;left, p, q);</span><br><span class="line">      auto* right = findAncestor(root-&gt;right, p, q);</span><br><span class="line">      if (left &amp;&amp; right) &#123;</span><br><span class="line">        return root;</span><br><span class="line">      &#125; else if (left) &#123;</span><br><span class="line">        return left;</span><br><span class="line">      &#125; else if (right) &#123;</span><br><span class="line">        return right;</span><br><span class="line">      &#125;</span><br><span class="line">      return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>239. 滑动窗口最大值</title>
    <url>/2023/01/26/leetcode/leetcode_239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
</blockquote>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>示例 2：</p>
<blockquote>
<p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>套用滑动窗口的框架写出代码</p>
<span id="more"></span>

<p>原始解法，窗口维持在label里；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">      &#125;</span><br><span class="line">      list&lt;<span class="type">int</span>&gt; label;</span><br><span class="line">      label.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; result = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 淘汰掉超出范围的数据</span></span><br><span class="line">        <span class="keyword">while</span> (label.<span class="built_in">front</span>() &lt; <span class="built_in">int</span>(i) + <span class="number">1</span> - k) &#123;</span><br><span class="line">          label.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((!label.<span class="built_in">empty</span>()) &amp;&amp; nums[i] &gt; nums[label.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">          label.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        label.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; &quot; idx: &quot; &lt;&lt; label.front() &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;front: &quot; &lt;&lt; nums[label.front()] &lt;&lt; std::endl;</span></span><br><span class="line">        result.<span class="built_in">emplace_back</span>(nums[label.<span class="built_in">front</span>()]);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>() + (k - <span class="number">1</span>), result.<span class="built_in">end</span>());</span><br><span class="line">      <span class="comment">// for (auto val : result) &#123;</span></span><br><span class="line">      <span class="comment">//   std::cout &lt;&lt; val &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>套用滑动窗口的框架写出代码 如下：</p>
<p>「单调队列」的核心思路和「单调栈」类似，push 方法依然在队尾添加元素，但是要把前面比自己小的元素 都删掉：<br>如果每个元素被加入时都这样操作，最终单调队列中的元素大小就会保持一个单调递减的顺序,max就是队头的第一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int max() &#123; </span><br><span class="line">  // 队头的元素肯定是最大的 </span><br><span class="line">  return q.front(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>pop 方法在队头删除元素 n，也很好写： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void pop(int n) &#123; </span><br><span class="line">  if (n == q.front()) &#123;</span><br><span class="line">     q.pop_front(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以要判断 data.front() &#x3D;&#x3D; n，是因为我们想删除的队头元素 n 可能已经被「压扁」了，可能已经不 存在了，所以这时候就不用删除了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单调队列的实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q_.<span class="built_in">empty</span>() &amp;&amp; q_.<span class="built_in">back</span>() &lt; n) &#123;</span><br><span class="line">      q_.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    q_.<span class="built_in">push_back</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q_.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == q_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">      q_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; q_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  MonotonicQueue window = <span class="keyword">new</span> <span class="built_in">MonotonicQueue</span>(); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//先填满窗口的前 k - 1</span></span><br><span class="line">      window.<span class="built_in">push</span>(nums[i]); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 窗口向前滑动，加入新数字 </span></span><br><span class="line">      windows.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">      <span class="comment">// 记录当前窗口的最大值 </span></span><br><span class="line">      res.<span class="built_in">push_back</span>(window.<span class="built_in">max</span>());</span><br><span class="line">      <span class="comment">// 移出旧数字 </span></span><br><span class="line">      window.<span class="built_in">pop</span>(nums[i - k + <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/2022/07/04/leetcode/leetcode_25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<blockquote>
<p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>借鉴反转链表的思路，每k个链表进行反转，只是要注意：</p>
<ol>
<li>当k为1时，不需要进行反转</li>
<li>当链表节点不足k个时，不需要反转，为此我们采用的思路是检查最后一组反转的节点数，如果小于k个，则再次反转一次，即：反转回原先的位置</li>
</ol>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">      head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">      ListNode* node = head;</span><br><span class="line">      ListNode* cur = head-&gt;next;</span><br><span class="line">      <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">      ListNode *label = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">while</span> ((count++ &lt; k) &amp;&amp; (cur != <span class="literal">nullptr</span>)) &#123; </span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">          label = cur;</span><br><span class="line">          cur = cur-&gt;next;</span><br><span class="line">          label-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>* tmpCur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = cur;</span><br><span class="line">        cur = tmpCur;</span><br><span class="line">        label-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur != <span class="literal">nullptr</span>) &amp;&amp; (count == k)) &#123;</span><br><span class="line">          count = <span class="number">0</span>;</span><br><span class="line">          node = label;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (count &lt;= k) &#123;</span><br><span class="line">        cur = node-&gt;next-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">auto</span>* tmp = cur-&gt;next;</span><br><span class="line">          cur-&gt;next = node-&gt;next;</span><br><span class="line">          node-&gt;next = cur;</span><br><span class="line">          cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>295. 数据流的中位数</title>
    <url>/2023/01/26/leetcode/leetcode_295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<p>例如 arr &#x3D; [2,3,4] 的中位数是 3 。<br>例如 arr &#x3D; [2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>实现 MedianFinder 类:</p>
<p>MedianFinder() 初始化 MedianFinder 对象。</p>
<p>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。</p>
<p>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</p>
<p>示例 1：</p>
<blockquote>
<p>输入<br>[“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]<br>输出<br>[null, null, null, 1.5, null, 2.0]</p>
</blockquote>
<blockquote>
<p>解释<br>MedianFinder medianFinder &#x3D; new MedianFinder();<br>medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]<br>medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]<br>medianFinder.findMedian(); &#x2F;&#x2F; 返回 1.5 ((1 + 2) &#x2F; 2)<br>medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]<br>medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>&#x2F;&#x2F; 分成两部分 构造大根堆 和 小根堆</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">public:</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">      ++cap_;</span><br><span class="line">      if (great_q_.empty() || num &lt;= great_q_.top()) &#123;</span><br><span class="line">        great_q_.push(num);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        less_q_.push(num);</span><br><span class="line">      &#125;</span><br><span class="line">      if (great_q_.size() == less_q_.size()) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (great_q_.size() &gt; less_q_.size() + 1) &#123;</span><br><span class="line">        less_q_.push(great_q_.top());</span><br><span class="line">        great_q_.pop();</span><br><span class="line">      &#125; else if (less_q_.size() &gt;= great_q_.size() + 1) &#123;</span><br><span class="line">        great_q_.push(less_q_.top());</span><br><span class="line">        less_q_.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; &quot;add &quot; &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;findMedian &quot; &lt;&lt; std::endl;</span><br><span class="line">      if (cap_ == 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      if (cap_ % 2 == 0) &#123;</span><br><span class="line">        return (great_q_.top() + less_q_.top()) / 2.0;</span><br><span class="line">      &#125;</span><br><span class="line">      return great_q_.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;int&gt; great_q_;</span><br><span class="line">    // 默认是 less&lt;int&gt; 大顶堆，初始化为小顶堆</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; less_q_;  </span><br><span class="line">    int cap_ = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>优先级队列</tag>
      </tags>
  </entry>
  <entry>
    <title>303. 区域和检索</title>
    <url>/2022/07/12/leetcode/leetcode_303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定一个整数数组  nums，处理以下类型的多个查询:</p>
<p>计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;&#x3D; right<br>实现 NumArray 类：</p>
<p>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + … + nums[right] )</p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>使用前缀和的思路，实现索引分段检索</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=303 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [303] 区域和检索 - 数组不可变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">      sum_.<span class="built_in">reserve</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">      sum_.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">      <span class="type">int</span> nums_sum = <span class="number">0</span>;</span><br><span class="line">      sum_.<span class="built_in">push_back</span>(nums_sum);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> val : nums) &#123;</span><br><span class="line">        nums_sum += val;</span><br><span class="line">        sum_.<span class="built_in">push_back</span>(nums_sum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sum_[right+<span class="number">1</span>] - sum_[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>304. 二维区域和检索</title>
    <url>/2022/07/11/leetcode/leetcode_304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<p>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 NumMatrix 类：</p>
<p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。</p>
<p><img src="/../../images/leetcode_304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/IMG_20220717-123926880.png" alt="picture 2">  </p>
<blockquote>
<p>输入:<br>[“NumMatrix”,”sumRegion”,”sumRegion”,”sumRegion”]<br>[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]<br>输出:<br>[null, 8, 11, 12]<br>解释:<br>NumMatrix numMatrix &#x3D; new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (红色矩形框的元素总和)<br>numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (绿色矩形框的元素总和)<br>numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (蓝色矩形框的元素总和)</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>根据前缀和的思路解答</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">      <span class="type">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      nums_ = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(rows+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; rows + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; cols + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">          nums_[i][j] = nums_[i<span class="number">-1</span>][j] + nums_[i][j<span class="number">-1</span>] - nums_[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nums_[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - nums_[row2+<span class="number">1</span>][col1] - nums_[row1][col2+<span class="number">1</span>] + nums_[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; nums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>438. 找到字符串中所有字母异位词</title>
    <url>/2022/11/26/leetcode/leetcode_438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
</blockquote>
<blockquote>
<p>输入: s &#x3D; “abab”, p &#x3D; “ab”<br>输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>套用滑动窗口的框架写出代码</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">      unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; label;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> c : p) &#123; ++label[c]; &#125;</span><br><span class="line">      <span class="type">int</span> curmet = label.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        ++right;</span><br><span class="line">        <span class="keyword">if</span> (label.<span class="built_in">find</span>(c) != label.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (--label[c] == <span class="number">0</span>) &#123;</span><br><span class="line">            --curmet;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right - left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (curmet == <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">char</span> d = s[left];</span><br><span class="line">          ++left;</span><br><span class="line">          <span class="keyword">if</span> (label.<span class="built_in">find</span>(d) != label.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (label[d] == <span class="number">0</span>) &#123;</span><br><span class="line">              ++curmet;</span><br><span class="line">            &#125;</span><br><span class="line">            ++label[d];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>316. 去除重复字母</title>
    <url>/2023/01/26/leetcode/leetcode_316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：s &#x3D; “bcabc”<br>输出：”abc”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：s &#x3D; “cbacdcbc”<br>输出：”acdb”</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>有点类似单调栈的思路<br>插入一个字符时，判断左边的字符是否比待插入字符小，并且后面还有机会插入，如果满足以上两个条件，就去掉该字符</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; charCount;</span><br><span class="line">      for_each(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> <span class="type">char</span> c)&#123;charCount[c]++;&#125;);</span><br><span class="line"></span><br><span class="line">      string result;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> val : s) &#123;</span><br><span class="line">        <span class="keyword">auto</span> findIter = charCount.<span class="built_in">find</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (findIter != charCount.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          --charCount[val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = result.<span class="built_in">find_first_of</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!result.<span class="built_in">empty</span>() &amp;&amp; result.<span class="built_in">back</span>() &gt; val) &#123;</span><br><span class="line">          <span class="keyword">auto</span> findIter = charCount.<span class="built_in">find</span>(result.<span class="built_in">back</span>());</span><br><span class="line">          <span class="keyword">if</span> ((findIter == charCount.<span class="built_in">end</span>()) || (findIter-&gt;second == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          result = result.<span class="built_in">substr</span>(<span class="number">0</span>, result.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result += val;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>503. 下一个更大元素II</title>
    <url>/2023/01/26/leetcode/leetcode_503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p>
<p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: nums &#x3D; [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；<br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: nums &#x3D; [1,2,3,4,3]<br>输出: [2,3,4,-1,4]</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>单调栈循环2*length写出代码</p>
<span id="more"></span>

<p>原始解法，窗口维持在label里；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; q = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; length * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">size_t</span> idx = i % length;</span><br><span class="line">        <span class="comment">// if (result[idx] != -1) &#123;</span></span><br><span class="line">        <span class="comment">//   continue;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()%length] &lt; nums[idx]) &#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;pop: &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line">          <span class="type">int</span> curidx = q.<span class="built_in">back</span>() % length;</span><br><span class="line">          <span class="keyword">if</span> (result[curidx] == <span class="number">-1</span>) &#123;</span><br><span class="line">            result[curidx] = nums[idx];</span><br><span class="line">          &#125;</span><br><span class="line">          q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;push_bck: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>560. 和为k的子数组</title>
    <url>/2022/07/26/leetcode/leetcode_560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,1], k &#x3D; 2<br>输出：2<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3], k &#x3D; 3<br>输出：2</p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>先计算出前缀和，然后使用前缀和之差计算出两个索引之间的数组之和</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        m[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始化的意义, 处理pre-k = 0的情况，此时个数应该增加1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            pre+=nums[i];  </span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(pre-k)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; &quot;find: &quot; &lt;&lt; pre -k &lt;&lt; &quot;,&quot; &lt;&lt; m[pre-k] &lt;&lt;std::endl;</span></span><br><span class="line">                s+=m[pre-k];</span><br><span class="line">            &#125;</span><br><span class="line">            m[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>567. 字符串的排列</title>
    <url>/2022/11/26/leetcode/leetcode_567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p>
<p>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p>
</blockquote>
<p>输入：s1&#x3D; “ab” s2 &#x3D; “eidboaoo”<br>输出：false</p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>套用滑动窗口的框架写出代码</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">      unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; label;</span><br><span class="line">      unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; current;</span><br><span class="line">      <span class="type">int</span> currentmet = <span class="number">0</span>;</span><br><span class="line">      for_each(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), [&amp;label](<span class="type">const</span> <span class="type">char</span> val)&#123;++label[val];&#125;);</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (j &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s2[j];</span><br><span class="line">        ++j;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; currentmet: &quot;</span> &lt;&lt; currentmet &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">find</span>(c) != string::npos) &#123;</span><br><span class="line">          <span class="keyword">if</span> (++current[c] == label[c]) &#123;</span><br><span class="line">            ++currentmet;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j - i &gt;= s1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (currentmet == label.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">char</span> d = s2[i];</span><br><span class="line">          ++i;</span><br><span class="line">          <span class="keyword">if</span> (s1.<span class="built_in">find</span>(d) != string::npos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[d] == label[d]) &#123;</span><br><span class="line">              --currentmet;</span><br><span class="line">            &#125;</span><br><span class="line">            --current[d];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>76. 最小覆盖子串</title>
    <url>/2022/07/26/leetcode/leetcode_76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p> </p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。
 </p>
<p>示例 1：</p>
<blockquote>
<p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>套用滑动窗口的框架写出代码</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : t) &#123;</span><br><span class="line">            need[val] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针表示滑动窗口</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> resulti = <span class="number">0</span>, resultj = s.<span class="built_in">size</span>()+<span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> cureq = <span class="number">0</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; curval;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> val = s[j];</span><br><span class="line">            <span class="keyword">auto</span> findIter = need.<span class="built_in">find</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (findIter == need.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curval[val]++;</span><br><span class="line">            <span class="keyword">if</span> (findIter-&gt;second == curval[val]) &#123;</span><br><span class="line">                cureq++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j - i + <span class="number">1</span> &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> findIter = need.<span class="built_in">find</span>(s[i]);</span><br><span class="line">                <span class="keyword">if</span> (findIter == need.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curval[s[i]] &gt; findIter-&gt;second) &#123;</span><br><span class="line">                    curval[s[i]]--;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cureq == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; resultj - resulti) &#123;</span><br><span class="line">                    resulti = i;</span><br><span class="line">                    resultj = j;</span><br><span class="line">                    <span class="comment">//std::cout &lt;&lt; &quot;result:  &quot; &lt;&lt; resultj &lt;&lt; &quot;,&quot; &lt;&lt; resulti &lt;&lt;std::endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cureq == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">substr</span>(resulti, resultj-resulti+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>99. 恢复二叉搜索树</title>
    <url>/2022/07/26/leetcode/leetcode_99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p>
<p><img src="/../../images/leetcode_99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/IMG_20220711-141333453.png" alt="picture 2">  </p>
<blockquote>
<p>输入：root &#x3D; [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>由于二叉搜索树的中序遍历是有序的，利用这个特性，使用中序遍历找到不符合要求的节点，交换两个节点即可</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">TranverseTree</span>(root);</span><br><span class="line">      <span class="keyword">if</span> (first_ &amp;&amp; second_) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(first_-&gt;val, second_-&gt;val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TranverseTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TranverseTree</span>(root-&gt;left);</span><br><span class="line">      <span class="keyword">if</span> (pre_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre_ = root;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;val &lt; pre_-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          first_ = pre_;</span><br><span class="line">        &#125;</span><br><span class="line">        second_ = root;</span><br><span class="line">      &#125;</span><br><span class="line">      pre_ = root;</span><br><span class="line">      <span class="built_in">TranverseTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* first_ = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* second_ = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* pre_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间节点</title>
    <url>/2022/07/11/leetcode/leetcode_876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<blockquote>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</p>
</blockquote>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>主要使用快慢指针的思路， 快指针每次移动2个节点，慢指针移动一个节点，当快指针到达最后则慢指针指向中间节点</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      ListNode *fast, *slow;</span><br><span class="line">      fast = slow = head;</span><br><span class="line">      <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>ds. 二叉树</title>
    <url>/2023/01/26/leetcode/leetcode_ds_%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="1-226-翻转二叉树"><a href="#1-226-翻转二叉树" class="headerlink" title="1 226_翻转二叉树"></a>1 226_翻转二叉树</h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a>1.1 Description</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<h3 id="1-2-Solution"><a href="#1-2-Solution" class="headerlink" title="1.2 Solution"></a>1.2 Solution</h3><p>采用后序遍历框架</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.处理左右子树</span></span><br><span class="line">      <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">      <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 处理当前节点</span></span><br><span class="line">      <span class="keyword">auto</span>* tmp = root-&gt;left;</span><br><span class="line">      root-&gt;left = root-&gt;right;</span><br><span class="line">      root-&gt;right = tmp;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-116-填充每个节点的下一个右侧节点指针"><a href="#2-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="2. 116_填充每个节点的下一个右侧节点指针"></a>2. 116_填充每个节点的下一个右侧节点指针</h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a>2.1 Description</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="2-2-Solution"><a href="#2-2-Solution" class="headerlink" title="2.2 Solution"></a>2.2 Solution</h3><p>采用后序遍历框架</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">      <span class="built_in">connectRecursive</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别处理两个节点的状态</span></span><br><span class="line">    <span class="function">Node* <span class="title">connectRecursive</span><span class="params">(Node* left, Node* right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      left-&gt;next = right;</span><br><span class="line">      <span class="built_in">connectRecursive</span>(left-&gt;left, left-&gt;right);</span><br><span class="line">      <span class="built_in">connectRecursive</span>(right-&gt;left, right-&gt;right);</span><br><span class="line">      <span class="built_in">connectRecursive</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="3-114-二叉树展开为链表"><a href="#3-114-二叉树展开为链表" class="headerlink" title="3. 114_二叉树展开为链表"></a>3. 114_二叉树展开为链表</h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a>3.1 Description</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<h3 id="3-2-Solution"><a href="#3-2-Solution" class="headerlink" title="3.2 Solution"></a>3.2 Solution</h3><p>采用前序遍历框架</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">flatterRecursive</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatterRecursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (result_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result_ = root;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result_-&gt;right = root; </span><br><span class="line">      &#125;</span><br><span class="line">      result_ = root;</span><br><span class="line">      <span class="keyword">auto</span>* left = root-&gt;left;</span><br><span class="line">      <span class="keyword">auto</span>* right = root-&gt;right;</span><br><span class="line">      root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">      root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="built_in">flatterRecursive</span>(left);</span><br><span class="line">      <span class="built_in">flatterRecursive</span>(right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* result_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-105-从前序与中序遍历序列构造二叉树"><a href="#4-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="4. 105_从前序与中序遍历序列构造二叉树"></a>4. 105_从前序与中序遍历序列构造二叉树</h2><h3 id="4-1-Description"><a href="#4-1-Description" class="headerlink" title="4.1 Description"></a>4.1 Description</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<h3 id="4-2-Solution"><a href="#4-2-Solution" class="headerlink" title="4.2 Solution"></a>4.2 Solution</h3><p>采用前序遍历框架</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">using</span> Viter = vector&lt;<span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">recursive</span>(preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>(), inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursive</span><span class="params">(Viter&amp;&amp; preBegin, Viter&amp;&amp; preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Viter&amp;&amp; inBegin, Viter&amp;&amp; inEnd)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (preBegin == preEnd || inBegin == inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> val = *preBegin;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">auto</span> iter = <span class="built_in">find</span>(inBegin, inEnd, val);</span><br><span class="line">      <span class="keyword">if</span> (iter == inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode* result = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">      <span class="type">int</span> leftsize = iter - inBegin + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; val &lt;&lt; &quot; , &quot; &lt;&lt; *(preEnd-1) &lt;&lt; &quot; , &quot; </span></span><br><span class="line">      <span class="comment">//     &lt;&lt; *inBegin &lt;&lt; &quot; , &quot; &lt;&lt; *(inEnd-1) &lt;&lt; &quot; , &quot; &lt;&lt; leftsize &lt;&lt; endl;</span></span><br><span class="line">      result-&gt;left = <span class="built_in">recursive</span>(preBegin+<span class="number">1</span>, preBegin + leftsize,</span><br><span class="line">                               <span class="built_in">move</span>(inBegin), <span class="built_in">move</span>(iter));</span><br><span class="line">      result-&gt;right = <span class="built_in">recursive</span>(preBegin + leftsize, <span class="built_in">move</span>(preEnd),</span><br><span class="line">                                <span class="built_in">move</span>(iter)+<span class="number">1</span>, <span class="built_in">move</span>(inEnd));</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// preorder = [3,9,20,15,7]</span></span><br><span class="line"><span class="comment">// inorder = [9,3,15,20,7]</span></span><br></pre></td></tr></table></figure>

<h2 id="5-106-从中序与后序遍历序列构造二叉树"><a href="#5-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="5. 106_从中序与后序遍历序列构造二叉树"></a>5. 106_从中序与后序遍历序列构造二叉树</h2><h3 id="5-1-Description"><a href="#5-1-Description" class="headerlink" title="5.1 Description"></a>5.1 Description</h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<h3 id="5-2-Solution"><a href="#5-2-Solution" class="headerlink" title="5.2 Solution"></a>5.2 Solution</h3><p>采用前序遍历框架</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Viter = vector&lt;<span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">buildTree</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), postorder.<span class="built_in">begin</span>(), postorder.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(Viter&amp;&amp; inBegin, Viter&amp;&amp; inEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Viter&amp;&amp; postBegin, Viter&amp;&amp; postEnd)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (inBegin == inEnd || postBegin == postEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> val = *(postEnd - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">auto</span> iter = <span class="built_in">find</span>(inBegin, inEnd, val);</span><br><span class="line">      <span class="keyword">if</span> (iter == inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> leftSize = iter - inBegin;</span><br><span class="line"></span><br><span class="line">      cout &lt;&lt; *inBegin &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; *(inEnd<span class="number">-1</span>) &lt;&lt; <span class="string">&quot; , &quot;</span></span><br><span class="line">           &lt;&lt; *postBegin &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; *(postEnd<span class="number">-1</span>) &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; leftSize &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">      root-&gt;left = <span class="built_in">buildTree</span>(<span class="built_in">move</span>(inBegin), <span class="built_in">move</span>(iter), <span class="built_in">move</span>(postBegin), postBegin + leftSize);</span><br><span class="line">      root-&gt;right = <span class="built_in">buildTree</span>(<span class="built_in">move</span>(iter+<span class="number">1</span>), <span class="built_in">move</span>(inEnd), postBegin + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inorder = [1,2,3,4]</span></span><br><span class="line"><span class="comment">// postorder = [2,1,4,3]</span></span><br></pre></td></tr></table></figure>

<h2 id="6-652-寻找重复的子树"><a href="#6-652-寻找重复的子树" class="headerlink" title="6. 652_寻找重复的子树"></a>6. 652_寻找重复的子树</h2><h3 id="6-1-Description"><a href="#6-1-Description" class="headerlink" title="6.1 Description"></a>6.1 Description</h3><p>给你一棵二叉树的根节点 root ，返回所有 重复的子树 。</p>
<p>对于同一类的重复子树，你只需要返回其中任意 一棵 的根结点即可。</p>
<p>如果两棵树具有 相同的结构 和 相同的结点值 ，则认为二者是 重复 的。</p>
<h3 id="6-2-Solution"><a href="#6-2-Solution" class="headerlink" title="6.2 Solution"></a>6.2 Solution</h3><p>难点是：如何判断重复的子树，本题中是采用<strong>序列化</strong>来表示二叉树，序列化后的字符串如果相同，则表示二叉树相同<br>采用后序遍历框架</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">recursive</span>(root);</span><br><span class="line">      <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">recursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">       <span class="keyword">auto</span> left = <span class="built_in">recursive</span>(root-&gt;left);</span><br><span class="line">       <span class="keyword">auto</span> right = <span class="built_in">recursive</span>(root-&gt;right);</span><br><span class="line">       string subTree = left + <span class="string">&quot;,&quot;</span> + right+ <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">       <span class="keyword">auto</span> find = treeStr_.<span class="built_in">find</span>(subTree);</span><br><span class="line">       <span class="keyword">if</span> (find == treeStr_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">         treeStr_.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(subTree, <span class="number">0</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (find-&gt;second == <span class="number">0</span>)&#123;</span><br><span class="line">         result_.<span class="built_in">push_back</span>(root);</span><br><span class="line">         treeStr_[subTree] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> subTree;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if (!root) &#123;</span></span><br><span class="line">      <span class="comment">//       return &quot;&quot;;</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">      <span class="comment">//   auto left = recursive(root-&gt;left);</span></span><br><span class="line">      <span class="comment">//   auto right = recursive(root-&gt;right);</span></span><br><span class="line">      <span class="comment">//   auto key = to_string(root-&gt;val) + &quot;,&quot; + left + &quot;,&quot; +right;</span></span><br><span class="line">      <span class="comment">//   if (treeStr_[key]++ == 1) &#123;</span></span><br><span class="line">      <span class="comment">//       result_.push_back(root);</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">//   return key;</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;TreeNode*&gt; result_;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; treeStr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-297-二叉树的序列化与反序列化"><a href="#7-297-二叉树的序列化与反序列化" class="headerlink" title="7. 297_二叉树的序列化与反序列化"></a>7. 297_二叉树的序列化与反序列化</h2><h3 id="7-1-Description"><a href="#7-1-Description" class="headerlink" title="7.1 Description"></a>7.1 Description</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<h3 id="7-2-Solution"><a href="#7-2-Solution" class="headerlink" title="7.2 Solution"></a>7.2 Solution</h3><!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      list&lt;TreeNode*&gt; label;</span><br><span class="line">      string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      label.<span class="built_in">push_back</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!label.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* node = label.<span class="built_in">front</span>();</span><br><span class="line">        label.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          result += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result += <span class="built_in">to_string</span>(node-&gt;val);</span><br><span class="line">          label.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">          label.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = result.<span class="built_in">substr</span>(<span class="number">0</span>, result.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;serialize result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      list&lt;TreeNode*&gt; label;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> pos = data.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">auto</span> valstr = data.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">      data = data.<span class="built_in">substr</span>(pos+<span class="number">1</span>, string::npos);</span><br><span class="line">      <span class="keyword">if</span> (valstr == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(valstr));</span><br><span class="line">      label.<span class="built_in">push_back</span>(root);</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;data1: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">while</span>(!label.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* curroot = label.<span class="built_in">front</span>();</span><br><span class="line">        label.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">          pos = data.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">          valstr = data.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">          data = data.<span class="built_in">substr</span>(pos+<span class="number">1</span>, string::npos);</span><br><span class="line">          <span class="comment">//cout &lt;&lt; &quot;data2: &quot; &lt;&lt; data &lt;&lt; endl;</span></span><br><span class="line">          <span class="keyword">if</span> (valstr == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(valstr));</span><br><span class="line">          label.<span class="built_in">push_back</span>(node);</span><br><span class="line">          <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            curroot-&gt;left = node;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curroot-&gt;right = node;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h2 id="8-1373-二叉搜索子树的最大键值和"><a href="#8-1373-二叉搜索子树的最大键值和" class="headerlink" title="8. 1373_二叉搜索子树的最大键值和"></a>8. 1373_二叉搜索子树的最大键值和</h2><h3 id="8-1-Description"><a href="#8-1-Description" class="headerlink" title="8.1 Description"></a>8.1 Description</h3><p>给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<p>任意节点的左子树中的键值都 小于 此节点的键值。<br>任意节点的右子树中的键值都 大于 此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p>
<h3 id="8-2-Solution"><a href="#8-2-Solution" class="headerlink" title="8.2 Solution"></a>8.2 Solution</h3><!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="type">bool</span> isBst = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">recursive</span>(root);</span><br><span class="line">      <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Info <span class="title">recursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;INT_MIN, INT_MAX, <span class="number">0</span>, <span class="literal">true</span>&#125;;   <span class="comment">// 注意默认值，方便后面逻辑统一</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      cout &lt;&lt; root-&gt;val &lt;&lt;  endl;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result_ &lt; root-&gt;val) &#123;</span><br><span class="line">          result_ = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;root-&gt;val, root-&gt;val, root-&gt;val, <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> left_info = <span class="built_in">recursive</span>(root-&gt;left);</span><br><span class="line">      <span class="keyword">auto</span> right_info = <span class="built_in">recursive</span>(root-&gt;right);</span><br><span class="line">      <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; &quot; left: &quot; &lt;&lt; left_info.max &lt;&lt; &quot; , &quot;</span></span><br><span class="line">      <span class="comment">//     &lt;&lt; left_info.min &lt;&lt; &quot; , &quot; &lt;&lt; left_info.sum </span></span><br><span class="line">      <span class="comment">//     &lt;&lt; &quot; , &quot; &lt;&lt; left_info.isBst &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">      <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; &quot; right: &quot; &lt;&lt; right_info.max &lt;&lt; &quot; , &quot;</span></span><br><span class="line">      <span class="comment">//     &lt;&lt; right_info.min &lt;&lt; &quot; , &quot; &lt;&lt; right_info.sum </span></span><br><span class="line">      <span class="comment">//     &lt;&lt; &quot; , &quot; &lt;&lt; right_info.isBst &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left &amp;&amp; (!left_info.isBst || root-&gt;val &lt;= left_info.max)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right &amp;&amp; (!right_info.isBst || root-&gt;val &gt;= right_info.min)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> sum = left_info.sum + root-&gt;val + right_info.sum;</span><br><span class="line">      <span class="keyword">if</span> (result_ &lt; sum) &#123;</span><br><span class="line">        result_ = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="built_in">max</span>(root-&gt;val, right_info.max), <span class="built_in">min</span>(root-&gt;val, left_info.min), sum, <span class="literal">true</span>&#125;; <span class="comment">// 逻辑统一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_ = <span class="number">0</span>;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="9-124-二叉树中的最大路径和"><a href="#9-124-二叉树中的最大路径和" class="headerlink" title="9. 124_二叉树中的最大路径和"></a>9. 124_二叉树中的最大路径和</h2><h3 id="9-1-Description"><a href="#9-1-Description" class="headerlink" title="9.1 Description"></a>9.1 Description</h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<h3 id="9-2-Solution"><a href="#9-2-Solution" class="headerlink" title="9.2 Solution"></a>9.2 Solution</h3><p>采用后序遍历</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">recursive</span>(root);</span><br><span class="line">      <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> left = <span class="built_in">recursive</span>(root-&gt;left);</span><br><span class="line">      <span class="type">int</span> right = <span class="built_in">recursive</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> result = root-&gt;val;</span><br><span class="line">      <span class="keyword">if</span> (left &gt; <span class="number">0</span>) result += left;</span><br><span class="line">      <span class="keyword">if</span> (right &gt; <span class="number">0</span>) result += right;</span><br><span class="line">      result_ = result &gt; result_ ? result : result_;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(left, right) + root-&gt;val, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_ = INT_MIN;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是二叉搜索树</p>
<hr>
<h2 id="10-230-二叉搜索树中第K小的元素"><a href="#10-230-二叉搜索树中第K小的元素" class="headerlink" title="10. 230_二叉搜索树中第K小的元素"></a>10. 230_二叉搜索树中第K小的元素</h2><h3 id="10-1-Description"><a href="#10-1-Description" class="headerlink" title="10.1 Description"></a>10.1 Description</h3><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<h3 id="10-2-Solution"><a href="#10-2-Solution" class="headerlink" title="10.2 Solution"></a>10.2 Solution</h3><p>采用中序遍历</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">recursive</span>(root, k);</span><br><span class="line">      <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recursive</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFind) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> left = <span class="built_in">recursive</span>(root-&gt;left, k);</span><br><span class="line">      <span class="keyword">if</span> (k == left + <span class="number">1</span>) &#123;</span><br><span class="line">        result_ = root-&gt;val;</span><br><span class="line">        isFind = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> right = <span class="built_in">recursive</span>(root-&gt;right, k - left - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> left + <span class="number">1</span> + right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_;</span><br><span class="line">    <span class="type">bool</span> isFind = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="11-538-把二叉搜索树转换为累加树"><a href="#11-538-把二叉搜索树转换为累加树" class="headerlink" title="11. 538_把二叉搜索树转换为累加树"></a>11. 538_把二叉搜索树转换为累加树</h2><h3 id="11-1-Description"><a href="#11-1-Description" class="headerlink" title="11.1 Description"></a>11.1 Description</h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>
<h3 id="11-2-Solution"><a href="#11-2-Solution" class="headerlink" title="11.2 Solution"></a>11.2 Solution</h3><p>采用中序遍历</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">Recursive</span>(root);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Recursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">int</span> right = <span class="built_in">Recursive</span>(root-&gt;right);</span><br><span class="line">      root-&gt;val = lastResult_ + root-&gt;val;</span><br><span class="line">      lastResult_ = root-&gt;val;</span><br><span class="line">      <span class="type">int</span> left = <span class="built_in">Recursive</span>(root-&gt;left);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lastResult_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="12-450-删除二叉搜索树中的节点"><a href="#12-450-删除二叉搜索树中的节点" class="headerlink" title="12. 450. 删除二叉搜索树中的节点"></a>12. 450. 删除二叉搜索树中的节点</h2><h3 id="12-1-Description"><a href="#12-1-Description" class="headerlink" title="12.1 Description"></a>12.1 Description</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<h3 id="12-2-Solution"><a href="#12-2-Solution" class="headerlink" title="12.2 Solution"></a>12.2 Solution</h3><p>采用前序遍历</p>
<p>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p>
<p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。 </p>
<p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右 子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      TreeNode* max_root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MAX);</span><br><span class="line">      max_root-&gt;left = root;</span><br><span class="line">      <span class="keyword">auto</span> findkey = <span class="built_in">findNode</span>(max_root, key);</span><br><span class="line">      <span class="keyword">if</span> (findkey == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">      <span class="built_in">deleteNode</span>(findkey);</span><br><span class="line">      <span class="keyword">return</span> max_root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; pre_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; pre_-&gt;val) &#123;</span><br><span class="line">          pre_-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pre_-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> parent = root;</span><br><span class="line">      <span class="comment">// 存在左子树的情况</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> left_max = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (left_max-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          parent = left_max;</span><br><span class="line">          left_max = left_max-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;parent: &quot;</span> &lt;&lt; parent-&gt;val </span><br><span class="line">             &lt;&lt; <span class="string">&quot; left_max: &quot;</span> &lt;&lt; left_max-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;val &gt; left_max-&gt;val) &#123;</span><br><span class="line">          parent-&gt;left = left_max-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          parent-&gt;right = left_max-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        left_max-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; pre_-&gt;val) &#123;</span><br><span class="line">          pre_-&gt;left-&gt;val = left_max-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pre_-&gt;right-&gt;val = left_max-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> right_min = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (right_min-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          parent = right_min;</span><br><span class="line">          right_min = right_min-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;val &gt; right_min-&gt;val) &#123;</span><br><span class="line">          parent-&gt;left = right_min-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          parent-&gt;right = right_min-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        right_min-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; pre_-&gt;val) &#123;</span><br><span class="line">          pre_-&gt;left-&gt;val = right_min-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pre_-&gt;right-&gt;val = right_min-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">findNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;val == key) <span class="keyword">return</span> root;</span><br><span class="line">      pre_ = root;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findNode</span>(root-&gt;left, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">findNode</span>(root-&gt;right, key);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* pre_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-1-Description"><a href="#13-1-Description" class="headerlink" title="13.1 Description"></a>13.1 Description</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<h3 id="13-2-Solution"><a href="#13-2-Solution" class="headerlink" title="13.2 Solution"></a>13.2 Solution</h3><p>采用后序遍历</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insertIntoBSTB</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBSTB</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == nullptt) &#123;</span><br><span class="line">                TreeNode* tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                root-&gt;left = tmp;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">insertIntoBST</span>(root-&gt;left, val)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                TreeNode* tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                root-&gt;right = tmp;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">insertIntoBST</span>(root-&gt;right, val)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>leetcode_116</tag>
        <tag>leetcode_226</tag>
      </tags>
  </entry>
</search>
